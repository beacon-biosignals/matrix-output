---
name: Job Context
description:
inputs:
  job-name:
    description: >-
      A string representing YAML data. Typically, a simple dictionary of key/value pairs.
    type: string
    default: ""
    required: false
outputs:
  job-name:
    value: ${{ inputs.job-name || steps.render.outputs.job-name }}
  job-id:
    value: ${{ steps.job-api.outputs.job-id }}
  job-ids:
    value: ${{ steps.job-api.outputs.job-ids }}
runs:
  using: composite
  steps:
    - uses: actions/checkout@v4
      if: ${{ inputs.job-name == '' }}
      with:
        ref: ${{ github.workflow_sha }}
        path: ${{ github.action_path }}/repo
    - id: workflow
      if: ${{ inputs.job-name == '' }}
      shell: bash
      run: |
        # Workflow job name template
        [[ "$RUNNER_DEBUG" -eq 1 ]] && set -x
        # e.g. octocat/hello-world/.github/workflows/my-workflow.yml@refs/heads/my_branch -> .github/workflows/my-workflow.yml
        workflow_path="$(echo "${workflow_ref%@*}" | cut -d/ -f3-)"
        job_name_template="$(job_key="${job_key}" yq '.jobs[env(job_key)].name' "${repo_path}/${workflow_path:?}")"
        echo "job-name-template=${job_name_template:?}" | tee -a "$GITHUB_OUTPUT"
      env:
        repo_path: ${{ github.action_path }}/repo
        workflow_ref: ${{ github.workflow_ref }}
        job_key: ${{ github.job }}
    - id: render
      if: ${{ inputs.job-name == '' }}
      shell: bash
      run: |
        # Render job name
        [[ "$RUNNER_DEBUG" -eq 1 ]] && set -x
        set -euo pipefail
        set -x
        # Determine if job name contains GitHub expressions. As GitHub expressions must be
        # closed we can just check for the opening sequence.
        if grep -qE '\$\{\{' <<<"${job_name_template}"; then
            # Convert GHA expressions into jq Bash expressions. Convert `null` to `""`.
            job_name_expr="$(perl -pe 's/\$\{\{\s*([a-z]+)\.([a-z0-9._-]+)\s*}}/\$(jq -r --arg p "\2" '\''getpath(\$p | split(".")) | select(type != "null")'\'' <<<"\${\1_json:?}")/g' <<<"${job_name_template}")"
            job_name="$(eval "echo \"${job_name_expr}\"")"
        else
            # GitHub adds job matrix values to job names which do not contain expressions.
            matrix_values="$(jq -r '[.. | select(type != "object")] | join(", ")' <<<"${matrix_json}")"

            if [[ -n "${matrix_values}" ]]; then
                job_name="${job_name_template} (${matrix_values})"
            else
                job_name="${job_name_template}"
            fi
        fi
        echo "job-name=${job_name:?}" | tee -a "$GITHUB_OUTPUT"
      env:
        job_name_template: ${{ steps.workflow.outputs.job-name-template }}

        # `jobs.<job_id>.name` can use the contexts: [github, needs, strategy, matrix, vars, inputs]
        # https://docs.github.com/en/actions/writing-workflows/choosing-what-your-workflow-does/contexts#context-availability
        github_json: ${{ toJSON(github) }}
        # needs_json: ${{ toJSON(needs) }}
        strategy_json: ${{ toJSON(strategy) }}
        matrix_json: ${{ toJSON(matrix) }}
        # vars_json: ${{ toJSON(vars) }}
        # inputs_json: ${{ toJSON(inputs) }}
    - id: job-api
      shell: bash
      run: |
        # Fetch job ID
        [[ "$RUNNER_DEBUG" -eq 1 ]] && set -x
        set -euo pipefail
        set -x
        jobs="$(gh api -X GET "/repos/{owner}/{repo}/actions/runs/${run_id:?}/attempts/${run_attempt:?}/jobs")"
        job_ids="$(jq -c --arg name "$job_name" '[.jobs[] | select(.name == $name) | .id]')"
        echo "job-ids=${job_ids:?}" | tee -a "$GITHUB_OUTPUT"

        if [[ $(jq length <<<"${job_ids}") -eq 1 ]]; then
            echo "job-id=$(jq 'first // empty' <<<"${job_ids}")" | tee -a "$GITHUB_OUTPUT"
        fi
      env:
        GH_TOKEN: ${{ github.token }}
        run_id: ${{ github.run_id }}
        run_attempt: ${{ github.run_attempt }}
        job_name: ${{ inputs.job-name || steps.render.outputs.job-name }}
