---
name: Matrix Output
description: >-
  Collect outputs from each matrix job.
inputs:
  yaml:
    description: >-
      A string representing YAML data. Typically, a simple dictionary of key/value pairs.
    type: string
    required: true
outputs:
  json:
    description: >-
      A string representing a JSON list of dictionaries. Each dictionary in the list
      contains the output for a single job from the job matrix. The order of this list
      corresponds to the job index (i.e. `strategy.job-index`).
    value: ${{ steps.merge.outputs.json }}
runs:
  using: composite
  steps:
    - uses: beacon-biosignals/matrix-output/job-context@dabf4aae56b754e4d2cbfd3319c294ebedd9ad42
      id: job
      with:
        path: ${{ github.action_path }}/repo
    - name: Generate job output
      shell: bash
      run: |
        input_json="$(yq -o=json <<<"${input_yaml:?}")"
        jq -ne \
            --argjson metadata "{\"job-id\": ${job_id:?}}" \
            --argjson outputs "${input_json:?}" \
            '$ARGS.named' | tee -a job-output.json
        touch job-sync
      env:
        input_yaml: ${{ inputs.yaml }}
        job_id: ${{ steps.job.outputs.job-id }}
    - name: Upload job output
      uses: actions/upload-artifact@v4
      with:
        name: matrix-output-${{ github.job }}-${{ strategy.job-index }}
        path: job-output.json
        if-no-files-found: error
    - name: Download job matrix outputs
      uses: actions/download-artifact@v4
      with:
        pattern: matrix-output-${{ github.job }}-*
        path: matrix-output
        merge-multiple: false
    - name: Determine matrix jobs
      id: matrix-jobs
      shell: bash
      run: |
        # Determine matrix jobs

        # Extract the recorded job IDs from the artifacts
        artifact_jobs="$(jq -rs '[.[].metadata."job-id"] | to_entries | map({id: .value, index: .key})' matrix-output/*/*.json)"
        artifact_job_ids="$(jq '[.[] | .id]' <<<"${artifact_jobs}")"

        # Fetch job information for all run attempts for this workflow. As the `filter=all`
        # query only seems to return completed jobs we'll perform two queries to get a
        # complete set of job information.
        run_jobs="$(
            jq -s '[.[] | {id, name, run_id, run_attempt, created_at, completed_at, conclusion}]' \
            <<<"$(gh api -X GET --paginate "/repos/{owner}/{repo}/actions/runs/${run_id:?}/jobs?filter=all" | jq --arg run_attempt "${run_attempt:?}" '.jobs[] | select(.run_attempt < $run_attempt)')" \
            <<<"$(gh api -X GET --paginate "/repos/{owner}/{repo}/actions/runs/${run_id:?}/attempts/${run_attempt:?}/jobs" | jq '.jobs[]')")"

        # gh api -X GET "/repos/{owner}/{repo}/actions/runs/${run_id:?}/jobs?filter=all" | jq '.jobs | map(select(.completed_at >= .created_at)) | sort_by(.created_at) | reverse | unique_by(.name) | [.[] | {id, conclusion}]')"

        # Determine the latest executed job. For each run attempt every job in the workflow
        # is given a new job ID even if that job isn't re-run. We filter out these jobs as
        # they will never have any associated artifacts.
        executed_jobs="$(jq 'map(select(.completed_at == null or .completed_at >= .created_at)) | sort_by(.created_at) | reverse | unique_by(.name)' <<<"${run_jobs}")"
        executed_job_ids="$(jq '[.[] | .id]' <<<"${executed_jobs}")"

        # Perform an intersection between the job ID lists
        matrix_jobs_ids="$(jq -n --argjson A "${executed_job_ids:?}" --argjson B "${artifact_job_ids:?}" '$A - ($A - $B) | unique')"
        matrix_jobs="$(jq --argjson m "${matrix_jobs_ids}" 'map(select(.id as $id | $m | index($id)))' <<<"$run_jobs")"

        num_matrix_jobs="$(jq length <<<"${matrix_jobs}")"
        echo "Matrix output ready ${num_matrix_jobs}/${{ strategy.job-total }}" >&2

        num_running_matrix_jobs="$(jq 'map(select(.conclusion == null)) | length' <<<"${matrix_jobs}")"

        # Specify our multiline output using GH action flavored heredocs
        # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
        {
            echo "num=${num_matrix_jobs}"
            echo "num-running=${num_running_matrix_jobs}"

            echo "json<<EOF"
            jq '.' <<<"${matrix_jobs}"
            echo "EOF"

            # TODO: Could be merged into matrix-jobs
            echo "artifact-jobs-json<<EOF"
            jq '.' <<<"${artifact_jobs}"
            echo "EOF"
        } | tee -a "$GITHUB_OUTPUT"
      env:
        GH_TOKEN: ${{ github.token }}
        prefix: matrix-output-${{ github.job }}-
        run_id: ${{ github.run_id }}
        run_attempt: ${{ github.run_attempt }}
    - name: Upload sync artifact
      uses: actions/upload-artifact@v4
      if: ${{ steps.matrix-jobs.outputs.num == strategy.job-total && steps.matrix-jobs.outputs.num-running > 1 }}
      with:
        name: matrix-output-sync-${{ github.job }}-${{ strategy.job-index }}
        path: job-sync
    - id: wait
      if: ${{ steps.matrix-jobs.outputs.num == strategy.job-total && steps.matrix-jobs.outputs.num-running > 1 }}
      shell: bash
      run: |
        # Wait for running matrix jobs
        set -x

        # Wait for remaining running jobs
        readarray -t running_job_ids <<<"$(jq -r --arg job_id "${job_id}" '.[] | select(.conclusion == null and .id != $job_id) | .id' <<<"${matrix_jobs}")"
        while [[ ${#running_job_ids[@]} -gt 0 ]]; do
            running_job_id="${running_job_ids[0]}"
            echo "Waiting for $running_job_id"

            job_index="$(jq --arg id "${running_job_id}" '.[] | select(.id == $id).index' <<<"${artifact_jobs}")"
            sync_artifact_name="${prefix}-${artifact_index}"

            # https://docs.github.com/en/rest/actions/artifacts?apiVersion=2022-11-28#list-workflow-run-artifacts
            artifacts="$(gh api -X GET "/repos/{owner}/{repo}/actions/runs/${run_id:?}/artifacts")"

            sync_artifact_exists="$(jq --arg name "${sync_artifact_name:?}" '.artifacts | map(select(.name == $name)) | any' <<<"${artifacts}")"
            if [[ "${sync_artifact_exists}" == "true" ]]; then
                running_job_ids=("${running_job_ids[@]:1}")  # Drop the first element
                continue
            fi

            running_job="$(gh api -X GET "/repos/{owner}/{repo}/actions/jobs/${running_job_id:?}")"
            is_running="$(jq '.conclusion != null' <<<"${running_job}")"

            if [[ "${is_running}" == "true" ]]; then
                running_job_ids=("${running_job_ids[@]:1}")  # Drop the first element
                continue
            fi
            
            sleep 5
        done
      env:
        matrix_jobs: ${{ steps.matrix-jobs.outputs.json }}
        artifact_jobs: ${{ steps.matrix-jobs.outputs.artifact-jobs-json }}
        run_id: ${{ github.run_id }}
        job_id: ${{ steps.job.outputs.job-id }}
        prefix: matrix-output-sync-${{ github.job }}
    - name: Merge job matrix output
      id: merge
      if: ${{ steps.matrix-jobs.outputs.num == strategy.job-total }}
      shell: bash
      run: |
        # Merge job matrix output

        # Specify our multiline output using GH action flavored heredocs
        # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
        {
            echo "json<<EOF"
            jq -s '[.[].outputs]' matrix-output/*/*.json
            echo "EOF"
        } | tee -a "$GITHUB_OUTPUT"
