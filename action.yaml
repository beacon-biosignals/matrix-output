---
name: Matrix Output
description: >-
  Collect outputs from each matrix job.
inputs:
  yaml:
    description: >-
      A string representing YAML data. Typically, a simple dictionary of key/value pairs.
    type: string
    required: true
outputs:
  json:
    description: >-
      A string representing a JSON list of dictionaries. Each dictionary in the list
      contains the output for a single job from the job matrix. The order of this list
      corresponds to the job index (i.e. `strategy.job-index`).
    value: ${{ steps.merge.outputs.json }}
runs:
  using: composite
  steps:
    - uses: beacon-biosignals/matrix-output/job-context@dabf4aae56b754e4d2cbfd3319c294ebedd9ad42
      id: job
      with:
        path: ${{ github.action_path }}/repo
    - name: Generate job output
      shell: bash
      run: |
        input_json="$(yq -o=json <<<"${input_yaml:?}")"
        jq -ne \
            --argjson metadata "{\"job-id\": ${job_id:?}}" \
            --argjson outputs "${input_json:?}" \
            '$ARGS.named' | tee -a job-output.json
      env:
        input_yaml: ${{ inputs.yaml }}
        job_id: ${{ steps.job.outputs.job-id }}
    - name: Upload job output
      uses: actions/upload-artifact@v4
      with:
        name: matrix-output-${{ github.job }}-${{ strategy.job-index }}
        path: job-output.json
        if-no-files-found: error
    - name: Download job matrix outputs
      uses: actions/download-artifact@v4
      with:
        pattern: matrix-output-${{ github.job }}-*
        path: matrix-output
        merge-multiple: false
    - name: Determine completed matrix jobs
      id: completed
      shell: bash
      run: |
        # Determine completed matrix jobs
        set -x

        # Extract the recorded job IDs from the artifacts
        artifact_job_ids="$(jq -rs '[.[].metadata."job-id"]' matrix-output/*/*.json)"

        # Determine the job for the latest attempt. For each attempt all jobs are given a
        # new job ID. We filter out these remove these jobs as we won't they will never
        # have any associated artifacts.
        jobs="$(gh api -X GET "/repos/{owner}/{repo}/actions/runs/${run_id:?}/jobs?filter=all" | jq '.jobs | map(select(.completed_at >= .created_at)) | sort_by(.created_at) | reverse | unique_by(.name) | [.[] | {id, conclusion}]')"

        successful_job_ids="$(jq 'map(select(.conclusion == "success") | .id)' <<<"${jobs}")"

        # Perform an intersection between the job ID lists
        matrix_jobs="$(jq -n --argjson A '${successful_job_ids:?}' --argjson B '${artifact_job_ids:?}' '$A - ($A - $B) | unique')"

        num_matrix_jobs="$(jq length <<<"${matrix_jobs}")"
        echo "Jobs completed ${num_matrix_jobs}/${{ strategy.job-total }}" >&2
        echo "num=${num_matrix_jobs:?}" | tee -a "$GITHUB_OUTPUT"
      env:
        GH_TOKEN: ${{ github.token }}
        prefix: matrix-output-${{ github.job }}-
        run_id: ${{ github.run_id }}
    - name: Merge job matrix output
      id: merge
      shell: bash
      run: |
        # Merge job matrix output

        # Specify our multiline output using GH action flavored heredocs
        # https://docs.github.com/en/actions/using-workflows/workflow-commands-for-github-actions#multiline-strings
        {
            echo "json<<EOF"
            jq -s '[.[].outputs]' matrix-output/*/*.json
            echo "EOF"
        } | tee -a "$GITHUB_OUTPUT"
